/*!
 *  Copyright 2018 by Contributors
 *  \file lbfgs.h
 *  \brief LBFGS (limited-memory BFGS or limited-strorate BFGS) optimizer
 *  \author WangYongJie
 */
#ifndef OPENMIT_OPTIMIZER_LBFGS_H_
#define OPENMIT_OPTIMIZER_LBFGS_H_

#include "openmit/optimizer/optimizer.h"

namespace mit {
/*!
 * \brief optimizer: lbfgs algorithm
 */
class LBFGSOptimizer : public Optimizer {
  public:
    /*! \brief constructor for LBFGS */
    LBFGSOptimizer(const mit::KWArgs& kwargs);
    
    /*! \brief destructor */
    ~LBFGSOptimizer();
    
    /*! \brief get LBFGS optimizer */
    static LBFGSOptimizer* Get(const mit::KWArgs& kwargs) {
      return new LBFGSOptimizer(kwargs);
    }
    
    void Init(mit_uint dim) override {}

    /*!
     * \brief parameter updater for mpi
     * \param idx model index 
     * \param g gradient of model index 
     * \param w model index weight
     */
     void Update(const mit_uint idx,
                 const mit_float g,
                 mit_float& w) override;

    /*! 
     * \brief model updater for parameter server interface
     * \param param optimizer parameter
     * \param key model feature id
     * \param idx entry data index
     * \param g gradient of unit index that computed by worker node
     * \param w model parameter of unit index 
     * \param weight used initialize optimizer middle variable
     */
    void Update(const mit::OptimizerParam & param, 
                const mit_uint & key, 
                const size_t & idx, 
                const mit_float & g,
                mit_float & w,
                mit::Entry * weight = nullptr) override;
    
    void Update(const mit_uint & key, 
                const size_t & idx, 
                const mit_float & g, 
                mit_float & w, 
                mit::Entry * weight = nullptr) override;

    void Run(int n,
             lbfgsfloatval_t *x,
             lbfgsfloatval_t *fx,
             lbfgs_evaluate_t proc_evaluate,
             lbfgs_progress_t proc_progress,
             void *instance,
             lbfgs_parameter_t *_param); 

    int progress(void *instance,
                 const lbfgsfloatval_t *x,
                 const lbfgsfloatval_t *g,
                 const lbfgsfloatval_t fx,
                 const lbfgsfloatval_t xnorm,
                 const lbfgsfloatval_t gnorm,
                 const lbfgsfloatval_t step,
                 int n,
                 int k,
                 int ls);
  private:
    /*! \brief lbfgs parameter */
    mit::OptimizerParam param_;
}; // class LBFGS


LBFGSOptimizer::LBFGSOptimizer(const mit::KWArgs & kwargs) {
  param_.InitAllowUnknown(kwargs);
  this->param_w_.InitAllowUnknown(kwargs);
}

LBFGSOptimizer::~LBFGSOptimizer() {}

void LBFGSOptimizer::Update(const mit_uint idx, const mit_float g, mit_float & w) {
  w -= param_.lr * g;
}

void LBFGSOptimizer::Update(const mit::OptimizerParam& param, 
                          const mit_uint& key, 
                          const size_t& idx, 
                          const mit_float& g,
                          mit_float& w, 
                          mit::Entry* weight) {
  w = g;
} // LBFGSOptimizer::Update

void LBFGSOptimizer::Update(const mit_uint& key, const size_t& idx, const mit_float& g, mit_float& w, mit::Entry* weight) {
  w = g;
} 

void LBFGSOptimizer::Run(int n,
                         lbfgsfloatval_t *x,
                         lbfgsfloatval_t *fx,
                         lbfgs_evaluate_t proc_evaluate,
                         lbfgs_progress_t proc_progress,
                         void *instance,
                         lbfgs_parameter_t *_param)
{
  CHECK_NOTNULL(x);
  CHECK_NOTNULL(fx);
  int ret = lbfgs(n, x, fx, proc_evaluate, proc_progress, instance, _param);
  LOG(INFO) << "L-BFGS optimization terminated with status code = " << ret;
} 


static int LBFGSOptimizer::_progress(
    void *instance,
    const lbfgsfloatval_t *x,
    const lbfgsfloatval_t *g,
    const lbfgsfloatval_t fx,
    const lbfgsfloatval_t xnorm,
    const lbfgsfloatval_t gnorm,
    const lbfgsfloatval_t step,
    int n,
    int k,
    int ls)
{   
    return reinterpret_cast<LBFGSOptimizer*>(instance)->progress(x, g, fx, xnorm, gnorm, step, n, k, ls);
}



int LBFGSOptimizer::progress(const lbfgsfloatval_t *x,
                             const lbfgsfloatval_t *g,
                             const lbfgsfloatval_t fx,
                             const lbfgsfloatval_t xnorm,
                             const lbfgsfloatval_t gnorm,
                             const lbfgsfloatval_t step,
                             int n,
                             int k,
                             int ls)
{
    LOG(INFO) << "Iteration:" << k << "  fx:" << fx << " xnorm:" << xnorm << " gnorm:" << gnorm << " step:" << step ;
    return 0;
}


} // namespace mit
#endif // OPENMIT_OPTIMIZER_LBFGS_H_
